/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("lib/almond-0.3.1", function(){});

define('hyojun.fuzzy-finder/model',[],function(){

	function levenstainTest(a, b){
		if(a.length === 0){
		 	return b.length;
		}
		if(b.length === 0){
			return a.length;
		}

		var i, j,alen, blen, matrix = [];

		alen = a.length;
		blen = b.length;
		// increment along the first column of each row
		for(i = 0; i <= blen; i++){
			matrix[i] = [i];
		}

		// increment each column in the first row
		for(j = 0; j <= alen; j++){
			matrix[0][j] = j;
		}

		// Fill in the rest of the matrix
		for(i = 1; i <= blen; i++){
			for(j = 1; j <= alen; j++){
				if(b.charAt(i-1) === a.charAt(j-1)){
					matrix[i][j] = matrix[i-1][j-1];
				} else {
					matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, // substitution
					Math.min(matrix[i][j-1] + 1, // insertion
					matrix[i-1][j] + 1)); // deletion
				}
			}
		}
		return matrix[blen][alen];
	}

	function containsBlob(value, list){
		return list.some(function(blob){
			return value.uid === blob.uid;
		});
	}

	function getUID(blob){
		var str = "", prop;
		for (prop in blob) {
			str += prop + ":" + (!!blob[prop] && typeof blob[prop] === "object" ? blob[prop].val : blob[prop]) + "^";
		}
		return str;
	}

	return {

		regexSuggestions : function(query, db, filters){

			var prop = 'c';
			if (query.match(/^url\!/)){
				prop = 'h';
				query = query.replace(/^url\!/,'');
				if (!query.length){
					return null;
				}
			}

			var reg;
			var result = [];
			try {
				reg = new RegExp(query.split('').join('.*?'), 'mgi');
			} catch(err){
				console.warn('malformed query: ',err);
				reg = null;
				return;
			}

			function testBlob(blob){

				var	match = blob[prop].indexOf(query);
				var val;
				var score;
				if (match !== -1){
					match = [query];
					score = 1;
				} else if(reg) {
					match = blob[prop].match(reg);
				}

				if (!!match && typeof match[0] === 'string' ){

					val = match[0].toLowerCase();
					score = score || query.length / val.length;

					if (score<0.3){
						//way tooo different from query
						return;
					}

					var matchingBlob = {};
					var blobVal, index;

					if (prop === 'h'){ //for url result a simple blob is enough

						blobVal = blob.h;

						//where selection starts
						index = blobVal.toLowerCase().indexOf(val);

						//to be rendered as url (different view)
						matchingBlob.t = blob.t;
						matchingBlob.h = {
							val : blobVal,
							match : [index, val.length]
						};

					} else { //normal blob. clone all props and set selection on match

						var eachProp;

						//shallow clone to preserve original blob
						for(eachProp in blob){

							blobVal = blob[eachProp];

							//apply selection index
							if (prop === eachProp){

								//where selection starts
								index = blobVal.toLowerCase().indexOf(val);
								matchingBlob[eachProp] = {
									val : blobVal,
									match : [index, val.length]
								};

							} else {
								matchingBlob[eachProp] = blob[eachProp];
							}
						}
					}

					//setting uid to avoid adding twice same targets.
					matchingBlob.uid = getUID(matchingBlob);
					matchingBlob.score = score;
					if (!containsBlob(matchingBlob, result)){
						result.push(matchingBlob);
					}
				}
			}

			db.map(function (value){
				if (!filters || filters.indexOf(value.t) !== -1){
					testBlob(value);
				}
			});

			//return results filtered by score relevancy
			return result.sort(function (a,b) {
				if (a.score > b.score){return -1;}
				else if (a.score< b.score){return 1;}
				return 0;
			});
		},

		levenstainSuggestions : function(query, db, filters){
			/*
					var obj, fuzzyness, foundList, index,
							edistance, score, wlength, length,
							clearList = [];

					fuzzyness = 0.3;

					foundList = [];
					index = 0;
					length = db.length;

					do {
						obj = db[index++];
						if (!!obj.href){
							edistance = levenstainTest(word, obj.href);
							length = Math.max(word.length, obj.href.length);
							obj.score = 1 - edistance/length;

							if (obj.score > fuzzyness){
								//console.log(obj.href);
								//console.log('edistance',edistance);
								//console.log('length',length);
								//console.log('obj.score ',obj.score );
								//console.error('------');
								foundList.push(obj);
							}
						}

					} while (index < length);


					function compare(a,b) {
						if (a.score < b.score)
							return -1;
						if (a.score > b.score)
							return 1;
						return 0;
					}

					foundList.sort(compare);

					foundList.forEach(function(item){
						clearList.push(JSON.stringify(item))
					})
					clearList.reverse();
					return clearList;

			*/
			return [];
		}
	};
});

define('hyojun.fuzzy-finder/view',[],function(){

	function dom(tag_name, config, content){
		var ele = document.createElement(tag_name);
		if (!!config && typeof config === 'object') {
			for (var prop in config){
				if (ele[prop]!==undefined){ele[prop] = config[prop]; }
				else {ele.setAttribute(prop, config[prop]); }
			}
		}
		if ('textContent' in ele !== undefined) {
			ele.textContent = (typeof config === 'string') ? config : (content || '');
		}
		return ele;
	}

	function getContentMatch (blob, contentClass) {

		var wrapper = document.createElement('span');
		if (typeof blob === 'string'){
			wrapper = dom('span', { className : contentClass}, blob);
		} else {
			wrapper = document.createDocumentFragment();

			var start = blob.match[0];
			var end = blob.match[1];

			// extract chunks from match to create the view.
			var left = blob.val.substr(0,start);
			var selection = blob.val.substr(start, end);
			var right = blob.val.substr(start+end, blob.val.length);

			if (!!left.length){
				wrapper.appendChild(dom('span',{
						className : contentClass
					},left)
				);
			}
			if (!!selection.length){
				wrapper.appendChild(dom('span',{
						className : 'selection'
					},selection)
				);
			}
			if (!!right.length){
				wrapper.appendChild(dom('span',{
						className : contentClass
					},right)
				);
			}
		}
		return wrapper.children ? wrapper : null;
	}

	function getRow(blob){

		if (typeof blob.c === 'object' || typeof blob.h === 'object'){

			var isURLItem = typeof blob.h === 'object';
			var li = dom('li');
			var a = dom('a',{
				'className' :'item ' + (blob.t||''),
				'href': blob.h.val || blob.h,
				'target': '_blank'
			});

			var content = getContentMatch(isURLItem ? blob.h : blob.c, 'content');
			if (!!content){
				li.appendChild(a).appendChild(content);
			}

			if (isURLItem === false){
				var url = getContentMatch(blob.h, 'url');
				if (!!url){
					li.appendChild(a).appendChild(url);
				}
			}
			return li;
		}
		return null;
	}

	function getRenderedList (list) {
		var frag = document.createDocumentFragment();
		list.forEach(function(val){
			var li = getRow(val);
			if (!!li){
				frag.appendChild(li);
			}
		});
		return frag;
	}

	var View = function(holder){
		this.holderEle = holder;
		this.result = [];
	};

	View.prototype = {

		clearResults : function(){
			while(this.holderEle.children.length){
				this.holderEle.children[0].onclick = null;
				this.holderEle.removeChild(this.holderEle.children[0]);
			}
			this.holderEle.scrollTop = 0;
			this.result = [];
			this.selectedItem = null;
		},

		close : function(){
			this.selectedItem = null;
			this.holderEle.className = this.holderEle.className.replace(' active','');
		},

		setSelected : function(index){
			var h = this.holderEle.offsetHeight;
			this.selectedItem = null;
			this.result.forEach(function(ele,i){
				if (i===index){
					this.selectedItem = ele;
					if (this.selectedItem.className.indexOf('hover') === -1){
						this.selectedItem.className += ' hover';
						var iT = this.selectedItem.offsetTop;
						var iH = this.selectedItem.offsetHeight;
						if (iT+iH > h){
							this.holderEle.scrollTop = (iT+iH) - h;
						} else {
							this.holderEle.scrollTop = 0;
						}
					}
				} else {
					ele.className = ele.className.replace(/\shover/gi,'');
				}
			}.bind(this));
		},

		render : function (list) {
			if (!list.length) {
				return;
			}
			var content = getRenderedList(list);
			this.holderEle.appendChild(content);
			this.result = Array.prototype.slice.call(this.holderEle.getElementsByTagName('li'));
			if (!!this.result.length && this.holderEle.className.indexOf('active')===-1){
				this.holderEle.className += ' active';
			}
		}

	};

	return View;
});

define('hyojun.fuzzy-finder/results-controller',[],function(){

	var NavController = function(view){
		this.view = view;
	};

	NavController.prototype = {

		reset : function(){
			this.selectedIndex = -1;
			this.resultLength = 0;
		},

		refresh : function(){
			this.resultLength = this.view.result.length;
			this.selectedIndex = -1;
		},

		check :function(event){
			//Esc (27) remove and clear the list
			if (event.keyCode === 27) {
				if (this.view.selectedItem){
					this.view.setSelected(-1);
					this.view.holderEle.scrollTop = 0;
					this.refresh();
					event.stopImmediatePropagation();
					return;
				}
			}

			//up and down start nav on results
			if (!!event.keyCode && [38,40].indexOf(event.keyCode) !== -1){
				if(!!this.resultLength){
					this.selectedIndex += event.keyCode===38 ? -1 : 1;
					this.selectedIndex = Math.min(this.selectedIndex, this.resultLength-1);
					this.selectedIndex = Math.max(this.selectedIndex,0);
					this.view.setSelected(this.selectedIndex);
					event.stopImmediatePropagation();
					return;
				}
			}
		},

		openSelected : function(){
			if (this.view && this.view.selectedItem){
				this.view.selectedItem.getElementsByTagName('a')[0].click();
			}
		}
	};

	return NavController;
});


define('hyojun.fuzzy-finder/controller',[ "hyojun.fuzzy-finder/model", "hyojun.fuzzy-finder/view", "hyojun.fuzzy-finder/results-controller" ], function ( Model, View, NavController) {

	var ctrl = function (input, resultHolder, db ) {
		this.db = db;
		this.inputEle = input;
		this.timeout = 0;
		this.view = new View(resultHolder);
		this.nav = new NavController(this.view);
		this.bindKeyboard();
	};

	ctrl.prototype = {

		bindKeyboard : function(){
			this.inputEle.form.addEventListener('submit', this.checkQuery.bind(this), false);
			this.inputEle.form.addEventListener('submit', this.nav.openSelected.bind(this.nav), false);
			this.inputEle.addEventListener('keyup', this.nav.check.bind(this.nav), false);
			this.inputEle.addEventListener('keyup', this.checkQuery.bind(this), false);
			this.inputEle.form.addEventListener('focusout', this.closeView.bind(this));
		},

		checkQuery : function (event) {

			if (event.type === 'submit'){
				event.preventDefault();
			}

			if (event.keyCode === 27) {
				if (this.nav.resultLength>0){
					this.query = null;
					this.inputEle.value = '';
					this.view.clearResults();
					this.closeView();
					return;
				}
			}

			//shift, command etc
			if (!!event.keyCode && [16,18,93,91,18,17].indexOf(event.keyCode) !== -1){
				return;
			}

			var q = this.inputEle.value;

			//c'mon, at least 2 chars to start searching.
			if (q.length < 3){
				this.closeView();
				return;
			}

			//query changed since last searcy?
			if(q === this.query && !!this.query){
				return;
			}

			this.query = this.inputEle.value;
			var filters = this.query.split(':')||[];
			var term = filters.pop();

			clearTimeout(this.timeout);
			if (!!term && term.length > 2){
				this.timeout = setTimeout(function(){
					this.getResult(term, filters);
				}.bind(this), this.resultLength ? 800 : 500);
			}
		},

		getResult : function(term, filters){

			//getting query timestamp;
			var qt = new Date().getTime();
			var result = Model.regexSuggestions(term, this.db, filters.length ? filters : null);
			qt = new Date().getTime() - qt;

			//getting render timestamp;
			var rt = new Date().getTime();

			if (!!result && !!result.length) {
				this.view.clearResults();
				console.dir(result);
				this.view.render(result);
				this.nav.refresh();
			} else {
				this.nav.reset();
				this.closeView();
			}
			rt = new Date().getTime() - rt;
			this.setQueryStatus('results:' + this.nav.resultLength + '/ query:' + qt + "ms/ render:" + rt+"ms");
		},

		closeView : function(event){
			clearTimeout(this.timeout);
			this.nav.reset();
			this.query = undefined;
			this.setQueryStatus('');
			this.view.clearResults();
			this.view.close();
		},

		setQueryStatus : function(value){
			this.inputEle.form.setAttribute('data-report', value);
		}
	};

	return function(db){
		var inputEle = document.getElementById('fuzzy-query');
		var resultEle = document.getElementById('fuzzy-result');
		if (!!inputEle && !!resultEle && !!db){
			inputEle.plugin = new ctrl(inputEle, resultEle, db);
		} else {
			console.warn('missing dependencies', inputEle, resultEle, db);
		}
	}

});

